# go-api

Краткое техническое описание
---------------------------
`go-api` — небольшой HTTP-сервис на Go, реализующий CRUD и аутентификацию пользователей через JWT. Сервис предоставляет HTTP JSON API для создания пользователей, входа (получения токена) и операций над сущностью `User`. Также служит статическим файловым сервером для простого веб-интерфейса в папке `web`.

Роль сервиса в архитектуре
-------------------------
- Основные задачи:
  - Регистрация пользователей (`/create`).
  - Аутентификация и выдача JWT-токенов (`/login`).
  - Получение списка пользователей (`/users`), обновление (`/update`) и удаление (`/delete`) — защищённые endpoints.
  - Раздача статического веб-интерфейса (`/web/` и `/`).
- Взаимодействие с другими компонентами:
  - Использует PostgreSQL (через `database.Connect()`), предполагается как отдельный сервис/инстанс БД.
  - JWT используется для межсервисной аутентификации пользователей/клиентов.

Технологический стек
--------------------
- Go: `go 1.25.4` (взято из `go.mod`).
- HTTP: стандартная библиотека `net/http` + маршрутизация `github.com/gorilla/mux v1.8.1`.
- JWT: `github.com/golang-jwt/jwt/v5 v5.3.0`.
- Конфигурация: `github.com/joho/godotenv v1.5.1` (подгрузка `.env`).
- БД: PostgreSQL драйвер `github.com/lib/pq v1.10.9`.
- Логирование: `github.com/rs/zerolog` (используется в `internal/logger`).

Точка входа приложения
----------------------
- Файл: `cmd/server/main.go`.
- Инициализация последовательности:
  1. `logger.InitLogger()` — инициализация `zerolog` (stdout, timestamp, caller).
  2. `godotenv.Load()` — подгрузка `.env` (если присутствует).
  3. Чтение `JWT_SECRET` из окружения и установка в `cmd/server/auth.JwtSecret`.
  4. `database.Connect()` — установка глобальной `internal/database.DB` (Postgres).
  5. `routes.RegisterRoutes()` — регистрация маршрутов в `gorilla/mux`.
  6. `http.ListenAndServe(":"+port, router)` — запуск HTTP-сервера (порт из `APP_PORT`, по умолчанию `8080`).

- Примечание: graceful shutdown и использование `context.Context` для остановки сервера не реализованы в текущей версии.

HTTP сервер
-----------
- Тип: HTTP (net/http) с маршрутизатором `gorilla/mux`.
- Формат обмена: JSON для API (`Content-Type: application/json`).
- Основные маршруты (см. `internal/routes/routes.go`):
  - `POST /create` — регистрация пользователя (публичный).
  - `POST /login` — логин и получение JWT (публичный).
  - `GET  /users` — получить список пользователей (JWT required).
  - `PUT  /update?id={id}` — обновить пользователя (JWT required).
  - `DELETE /delete?id={id}` — удалить пользователя (JWT required).
  - `GET /web/...` — статические файлы из `./web`.
  - `GET /` — служит `web/index.html` (корневая страница).
- Middleware:
  - `internal/middleware.JWTAuth` — проверяет `Authorization: Bearer <token>` и вызывает `cmd/server/auth.VerifyToken`.
- Таймауты сервера: в текущей реализации сервер запускается через `http.ListenAndServe` без настройки `ReadTimeout`/`WriteTimeout`/`IdleTimeout`.

Структура проекта
-----------------
- `cmd/server` — точка входа и пакет `auth` (с функциями `GenerateToken`, `VerifyToken`, `ExtractToken`).
- `internal` — основной код приложения, разделён по слоям:
  - `internal/routes` — регистрация маршрутов.
  - `internal/handler` — HTTP handlers (parse/validate/request handling).
  - `internal/service` — бизнес-логика (оркестрация, валидация через `models`).
  - `internal/repository` — SQL-операции (Postgres), возвращает доменные объекты.
  - `internal/models` — модели и валидация (`User.ValidateForCreate/Update`).
  - `internal/database` — подключение к БД (`Connect()` + глобальная `DB *sql.DB`).
  - `internal/logger` — инициализация `zerolog`.
  - `internal/middleware` — JWT middleware.
  - `internal/config` — вспомогательная загрузка конфигурации (`LoadConfig`).
- `web` — статические HTML/JS для быстрой проверки API (интерфейс использует `http://localhost:8080` как `API_URL`).

Принципы разделения ответственности
----------------------------------
- Сохранён стандартный flow: маршруты → handlers → service → repository → database.
- Валидация полей пользователя реализована в `models` и используется в `service`.
- Репозиторий содержит SQL и возвращает доменные структуры; hander'ы иногда напрямую используют `database.DB` (есть смешение ответственности).

Работа с данными
-----------------
- БД: PostgreSQL через `database/sql` + `github.com/lib/pq`.
- Репозиторий использует параметризованные запросы (`$1`) — это предотвращает SQL-инъекции на уровне запросов.
- Транзакции: в коде не реализованы (нет `Begin`/`Commit`/`Rollback`).
- Retry / circuit breaker: отсутствуют.
- Обработка ошибок: репозитории возвращают `error`; HTTP handlers конвертируют ошибки в HTTP-ответы (`http.Error`). В бизнес-логике panic не встречается.

Аутентификация и безопасность
-----------------------------
- JWT: используется `github.com/golang-jwt/jwt/v5` в `cmd/server/auth`.
- `JwtSecret` принимает значение из `JWT_SECRET` окружения; если не задан — остаётся значение по умолчанию в коде.
- Замечания по безопасности (факты текущей реализации):
  - Хранение паролей: в текущей реализации пароли сохраняются и сравниваются в явном виде (plaintext). В production это уязвимо — требуется использование `bcrypt`/`argon2`.
  - Нет защиты от brute-force / rate limiting.
  - Отсутствует управление сроком жизни refresh-токенов (только access token с 24h в claims).
  - В проекте присутствует ещё один пакет `internal/auth` с альтернативной реализацией генерации токена — это дублирование и может привести к путанице.

Конфигурация
-------------
- Конфигурация через environment variables и `godotenv` (опционально `.env` файл).
- Основные переменные (пример):
  - `DB_HOST` — адрес Postgres.
  - `DB_PORT` — порт Postgres.
  - `DB_USER` — пользователь БД.
  - `DB_PASS` — пароль БД.
  - `DB_NAME` — имя базы данных.
  - `APP_PORT` — порт приложения (по умолчанию `8080`).
  - `JWT_SECRET` — секрет для подписи JWT (рекомендуется задавать обязательно).

Сборка и запуск
----------------
Требования:
- Установлен Go (версия совместима с `go 1.25.4`).
- Доступ к PostgreSQL (локально или удалённо) и корректные `DB_*` переменные.

Команды (локальная проверка):
```bash
go mod tidy
go run ./cmd/server
```

Пример `.env` (не храните реальные секреты в репозитории):
```
DB_HOST=127.0.0.1
DB_PORT=5432
DB_USER=postgres
DB_PASS=secret
DB_NAME=go_api_db
APP_PORT=8080
JWT_SECRET=replace_this_with_strong_secret
```

Порт и URL сервиса
- По умолчанию: `http://localhost:8080`.

HealthCheck
-----------
- В текущей реализации явного health endpoint'а нет (не реализован `/health` или подобный). Для базовой проверки доступности сервиса можно:
  - Запросить корень: `GET /` — отдаёт статический `web/index.html`.
  - Проверить подключение к БД программно (функция `database.Connect()` пингует БД при старте).

Логирование и ошибки
--------------------
- Логирование: `internal/logger` использует `zerolog` и пишет в stdout с timestamp и caller.
- Формат ошибок в HTTP handlers: в большинстве случаев используется `http.Error` с текстовым сообщением и соответствующим кодом (`400`, `401`, `404`, `500`).

Критерии готовности (Acceptance criteria)
-----------------------------------------
- `go build ./...` выполняется без ошибок (проверить в окружении с корректными модулевыми зависимостями).
- Сервис запускается локально: `go run ./cmd/server` и слушает порт `APP_PORT` (по умолчанию `8080`).
- Основные эндпоинты отвечают (см. раздел "HTTP сервер").

Известные ограничения и рекомендации (технический обзор)
------------------------------------------------------
- Хранение паролей: заменить хранение plaintext на `bcrypt` (например, `golang.org/x/crypto/bcrypt`).
- Добавить graceful shutdown и использование `context.Context` для корректного завершения сервера и фоновых операций.
- Ввести health endpoint `/health` или `/ready` и `/live` для оркестраторов (k8s).
- Перенести `auth`-пакет в одно место (например, `internal/auth`) и удалить дублирующийся код в `cmd/server/auth`.
- Добавить серверные таймауты (`http.Server{ReadTimeout, WriteTimeout, IdleTimeout}`) и лимит размера тела запроса.
- Добавить миграции БД и схемы (например, `golang-migrate`) и пример скрипта создания таблицы `users`.

